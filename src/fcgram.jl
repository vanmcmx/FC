export FCGram
export get_period

"""
    FCGram(
    params::FCGramParameters, 
    leftbc::BCondition=DirichletBC(), 
    rightbc::BCondition=DirichletBC())

Generate a vector `dfcvalues` with the approximated values of the `k`-th order derivative of a real-valued smooth function `f` 
on a uniform partition of the interval `[0,1]` spectral differentiation of the periodic extension `fᶜ` generated by FC Gram.  
The FC Gram operator is generated as sum of leftward and rightward continuation operators, which in turn are projections 
onto the Gram bases followed by blend-to-zero operators. The arithmetic precision for the computation of both the Gram bases 
and the blend-to-zero operator can be set by the keyword argument `ndig`. In addition, the FC coefficients can be filtered by 
passing a function to the keyword argument `filtering!`.

Compute the vector with the FC values on a uniform partition of the full continuation interval as 
> [fvalues; (Al + Ar) ⋅ fvalues]

where
- `Al` is the leftward blend-to-zero operator
- `Ar` is the rightward blend-to-zero operator
- `fvalues` is the vector with the function values on the interval [0,1]

This routine is an implementation of the 1D FC-Gram described in *F. Amlani & O. P. Bruno* 
[*An FC-based spectral solver for elastodynamic problems in general three-dimensional domains*](https://doi.org/10.1016/j.jcp.2015.11.060)

**Example:** Approximation of the first order derivative of a sinuidal function on a uniform grid on the interval `[0,1]`. 

```julia
N = 100
fvalues = 2range(start=0,stop=1, length=N) .|> cospi
params = FCGramParameters{BigInt}(N=N)
leftOp = fcGramLeftOp_Dirichlet(params)
rightOp = fcGramRightOp_Dirichlet(params)
dfcvalues = fcGram_derivatives(leftOp, rightOp, fvalues, k=1)
```
"""
struct FCGram{T, I<:Integer, B<:FCGramBlendZero} <: FCOperator{T}
    leftOp::B
    rightOp::B
    C::I
    N::I

    function FCGram(leftOp::B, rightOp::B, C::I, N::I) where {I<:Integer, B<:FCGramBlendZero}
        Cl = npts_Iblend(leftOp)
        Cr = npts_Iblend(rightOp)
        
        msg1 = "negative parameters"
        msg2 = "both Op must have $C pts on Iblend"
        N > zero(I) && C > zero(I) || throw(ArgumentError(msg1))
        C == Cl == Cr || throw(DimensionMismatch(msg2))
        T = get_fctype(leftOp, rightOp)
        new{T,I,B}(leftOp, rightOp, C, N)
    end
end

function FCGram(
    params::FCGramParameters,
    leftbc::Type{<:BoundaryCondition}=DirichletBC,
    rightbc::Type{<:BoundaryCondition}=DirichletBC;
    verbose=false)
    params.d = params.dl
    opl = FCGramBlendZero(leftbc, params; verbose=verbose)
    params.d = params.dr
    opr = FCGramBlendZero(rightbc, params; verbose=verbose)
    FCGram(opl, opr, params.C, params.N)
end

(op::FCGram)(fvalues::AbstractVector) = _eval(op, fvalues)

function get_fctype(Op1::FCGramBlendZero, Op2::FCGramBlendZero)
    Tl = typeof(Op1).parameters |> first
    Tr = typeof(Op2).parameters |> first
    promote_type(Tl,Tr)
end

function _eval(op::FCGram, fvalues::AbstractVector)
    fcleft = leftop_eval(op.leftOp, fvalues)
    fcright = rightop_eval(op.rightOp, fvalues)
    fcleft + fcright
end

"""
    leftop_eval(op::FCGramBlendZero, fvalues::AbstractVector)

Compute `Rc⋅Aℓ⋅Rd⋅fℓ`, where `Aℓ` is a `C×dℓ` matrix represents the projection on the Gram-basis followed 
by the leftward blend-to-zero operator, `fℓ` is a vector given the first `dℓ` entries of `fvalues`, 
`Rc` and `Rd`are permutation matrices that reverse the entries.
"""
function leftop_eval(op::FCGramBlendZero, fvalues::AbstractVector)
    n = length(fvalues)
    AQt = get_matrix(op)
    d = size(AQt, 2)
    msg = "ncols(AℓQℓᵀ) = $d > $n = length(f)"
    n ≥ d || throw(DimensionMismatch(msg))
    fl = fvalues[1:d] |> reverse
    reverse(AQt * fl)
end

"""
    rightop_eval(op::FCGramBlendZero, fvalues::AbstractVector)

Compute `Aᵣfᵣ`, where the `Aᵣ` is a `C×dᵣ` matrix that represents the projection on the Gram-basis followed 
by the rightward blend-to-zero operator and `fᵣ` is a vector given by the last `dᵣ` entries of `fvalues`.
"""
function rightop_eval(op::FCGramBlendZero, fvalues::AbstractVector)
    n = length(fvalues)
    AQt = get_matrix(op)
    d = size(AQt, 2)
    msg = "ncols(AᵣQᵣᵀ) = $d > $n = length(f)"
    n ≥ d || throw(DimensionMismatch(msg))
    fr = fvalues[end-d+1:end]
    AQt * fr
end

npts_Iblend(op::FCGram) = op.C

npts_Iunit(op::FCGram) = op.N

function get_period(op::FCGram) 
    !isone(op.N) || throw(DivideError())
    b = op.N + op.C
    b /= op.N - oneunit(op.N)
    return b
end